<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中等数学科教育法Ⅳ 順列・組合せ</title>
    <style>
        :root {
            --bg-color: #f4f7f9;
            --panel-bg: #ffffff;
            --text-color: #333;
            --accent-color: #2c3e50;
            --tree-line-color: #005c7a;
            --tree-line-width: 3px;
            --node-width: 140px; /* 縦の位置を揃えるための固定幅 */
            --card-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        /* --- Layout --- */
        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            max-width: 1500px;
            width: 100%;
            margin-bottom: 30px;
        }

        .panel {
            background: var(--panel-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            height: fit-content;
        }

        h3 {
            margin-top: 0;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 10px;
            margin-bottom: 15px;
            color: var(--accent-color);
            font-size: 1.1rem;
        }

        h4 {
            margin: 15px 0 10px 0;
            font-size: 0.95rem;
            color: #666;
        }

        /* Inputs */
        .input-group { display: flex; gap: 8px; margin-bottom: 10px; }
        input[type="text"] {
            width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;
        }
        button { cursor: pointer; border: none; font-weight: bold; transition: 0.2s; }
        .btn-add { background: var(--accent-color); color: white; padding: 0 15px; border-radius: 8px; flex-shrink: 0; }
        .btn-add:hover { opacity: 0.9; }

        /* Item Settings Table */
        .settings-list {
            list-style: none;
            padding: 0;
            margin: 0;
            border: 1px solid #eee;
            border-radius: 8px;
            overflow: hidden;
        }
        .settings-item {
            background: #fff;
            border-bottom: 1px solid #eee;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .settings-item:last-child { border-bottom: none; }
        
        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
        }
        
        .item-config {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f9f9f9;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 12px;
        }

        .count-input {
            width: 50px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }

        /* Method Selector */
        .method-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-bottom: 20px; }
        .method-btn {
            padding: 10px 5px; border-radius: 6px; background: #eaeff5; color: #555; font-size: 11px;
        }
        .method-btn.active { background: var(--accent-color); color: white; }

        /* Matrix */
        .matrix-wrapper { overflow-x: auto; margin-top: 15px; }
        .matrix-table { width: 100%; border-collapse: collapse; font-size: 13px; }
        .matrix-table th { color: var(--accent-color); padding: 8px; border-bottom: 2px solid #ddd; min-width: 30px; }
        .matrix-table td { padding: 8px; border-bottom: 1px solid #eee; text-align: center; }
        .matrix-checkbox { width: 18px; height: 18px; accent-color: var(--accent-color); cursor: pointer; }

        /* --- Right Panel --- */
        #result-area { width: 100%; }
        
        .result-header {
            display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 10px; flex-wrap: wrap; gap: 15px;
        }
        .header-left h3 { border: none; margin: 0; padding:0; font-size: 1.5rem; }
        .header-left p { margin: 5px 0 0 0; color: #666; font-size: 0.9rem; }

        /* New Controls Row for View Toggle */
        .controls-row {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }

        .view-toggle {
            display: flex; background: #eaeff5; padding: 4px; border-radius: 8px;
        }
        .view-btn {
            padding: 8px 16px; border-radius: 6px; background: transparent; color: #666; font-size: 13px;
            display: flex; align-items: center; gap: 6px;
        }
        .view-btn.active {
            background: white; color: var(--accent-color); box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .view-btn svg { width: 16px; height: 16px; }

        .count-badge {
            background: var(--accent-color); color: white; padding: 5px 15px; border-radius: 20px; font-weight: bold; font-size: 1.2rem;
            margin-left: auto;
        }

        /* --- Groups Layout --- */
        .groups-container { display: flex; flex-direction: column; gap: 25px; }
        .group-block {
            background: var(--panel-bg); border-radius: 12px; border-left: 5px solid var(--accent-color); box-shadow: var(--card-shadow); overflow: hidden;
        }
        .group-header {
            background: #f8f9fa; padding: 12px 20px; border-bottom: 1px solid #eee; font-weight: bold; color: #555; display: flex; justify-content: space-between; align-items: center;
        }
        .group-content { padding: 20px; }
        .group-content.visual-mode { display: flex; flex-wrap: wrap; gap: 20px; align-items: center; }
        .group-content.tree-mode { display: block; padding: 30px; overflow-x: auto; }

        /* Tree CSS (Aligned Columns) */
        .tf-tree { display: flex; align-items: center; font-family: "Helvetica Neue", Arial, sans-serif; }
        .tf-nc {
            padding: 5px 10px; font-weight: bold; font-size: 14px; color: #000; white-space: nowrap; background: #fff; z-index: 2;
            width: var(--node-width); text-align: center; display: flex; justify-content: center;
        }
        .tf-connector { width: 25px; height: var(--tree-line-width); background-color: var(--tree-line-color); }
        .tf-children { display: flex; flex-direction: column; }
        .tf-branch { display: flex; align-items: center; position: relative; padding-left: 25px; }
        .tf-branch::before {
            content: ''; position: absolute; left: 0; top: 50%; width: 25px; height: var(--tree-line-width); background-color: var(--tree-line-color); transform: translateY(-50%);
        }
        .tf-branch::after {
            content: ''; position: absolute; left: 0; width: var(--tree-line-width); background-color: var(--tree-line-color);
        }
        .tf-branch:only-child::after { display: none; }
        .tf-branch:first-child:not(:only-child)::after { top: 50%; height: 50%; }
        .tf-branch:last-child:not(:only-child)::after { top: 0; height: 50%; }
        .tf-branch:not(:first-child):not(:last-child)::after { top: 0; height: 100%; }

        /* Visual Mode */
        .viz-card { background: white; border: 1px solid #eee; border-radius: 8px; padding: 15px; display: flex; justify-content: center; align-items: center;}
        .node { min-width: 40px; height: 40px; padding: 0 12px; border-radius: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 13px; color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.2); z-index: 2; border: 2px solid white; white-space: nowrap; box-sizing: border-box; }
        .layout-linear { display: flex; align-items: center; gap: 5px; }
        .arrow { color: #ccc; font-size: 16px; font-weight: bold; margin: 0 2px; }
        .layout-circular { position: relative; width: 160px; height: 160px; }
        .circular-bg { position: absolute; top: 10px; left: 10px; right: 10px; bottom: 10px; border: 2px dashed #ddd; border-radius: 50%; }
        .circular-node { position: absolute; transform: translate(-50%, -50%); }
        .layout-group { border: 2px solid #ccc; border-radius: 30px; padding: 15px; display: flex; flex-wrap: wrap; gap: 8px; background: #fafafa; justify-content: center; }

        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>

    <div class="container">
        <!-- LEFT PANEL -->
        <div class="panel">
            <h3>設定</h3>

            <!-- 1. Add Item -->
            <h4>① 項目の追加</h4>
            <div class="input-group">
                <input type="text" id="new-item-input" placeholder="名前 (例: 赤玉)" onkeypress="handleEnter(event)">
                <button class="btn-add" onclick="addItem()">追加</button>
            </div>

            <!-- 2. Configure Items -->
            <h4>② 個数・区別の設定</h4>
            <ul class="settings-list" id="settings-list">
                <!-- Settings rows injected here -->
            </ul>

            <!-- 3. Method & Pick -->
            <h4>③ 計算方法</h4>
            <div class="method-grid">
                <button class="method-btn active" onclick="setMethod('permutation')" id="btn-perm">順列<br>(並べる)</button>
                <button class="method-btn" onclick="setMethod('circular')" id="btn-circ">円順列<br>(回す)</button>
                <button class="method-btn" onclick="setMethod('combination')" id="btn-comb">組合せ<br>(選ぶ)</button>
            </div>

            <div style="display:flex; justify-content:space-between; margin-bottom:10px; align-items: center;">
                <label style="font-size:14px;">選ぶ数:</label>
                <input type="number" id="pick-count" value="3" min="1" max="10" style="width: 60px; padding:5px;" onchange="updateCalc()">
            </div>

            <!-- 4. Constraints -->
            <div style="border-top: 2px dashed #eee; padding-top:15px; margin-top:20px;">
                <label style="font-size:12px; font-weight:bold; color:#666;">条件指定 (表形式)</label>
                <div id="matrix-container" class="matrix-wrapper"></div>
            </div>
        </div>

        <!-- RIGHT PANEL -->
        <div id="result-area">
            <!-- Header Row: Title & Count -->
            <div class="result-header">
                <div class="header-left">
                    <h3>結果一覧</h3>
                </div>
                <div class="count-badge" id="result-count">0 通り</div>
            </div>

            <!-- Controls Row: View Toggle (Moved here) -->
            <div class="controls-row">
                <div class="view-toggle">
                    <button class="view-btn active" id="btn-view-visual" onclick="setViewMode('visual')">
                        <!-- Icon Grid -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                        図解
                    </button>
                    <button class="view-btn" id="btn-view-tree" onclick="setViewMode('tree')">
                        <!-- Icon Tree -->
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M2 12h20"></path><path d="M2 12v-6c0-1.1.9-2 2-2h4"></path><path d="M2 12v6c0 1.1.9 2 2 2h4"></path><path d="M12 12h4"></path><circle cx="20" cy="12" r="2"></circle><circle cx="10" cy="4" r="2"></circle><circle cx="10" cy="20" r="2"></circle></svg>
                        樹形図
                    </button>
                </div>
            </div>
            
            <div id="groups-output" class="groups-container"></div>
        </div>
    </div>

    <script>
        // Data Structure: { name: string, count: number, distinct: boolean }
        let itemsData = [
            { name: "ニューヨーク", count: 1, distinct: false },
            { name: "ロンドン", count: 1, distinct: false },
            { name: "東京", count: 1, distinct: false }
        ];
        
        // Flattened list of strings used for actual calculation
        let currentPool = [];

        let currentMethod = 'permutation'; 
        let viewMode = 'visual'; 
        let matrixConstraints = {}; 
        const colors = ['#e74c3c', '#3498db', '#27ae60', '#f39c12', '#9b59b6', '#1abc9c', '#34495e', '#d35400'];

        const settingsListEl = document.getElementById('settings-list');
        const matrixContainer = document.getElementById('matrix-container');
        const groupsOutput = document.getElementById('groups-output');
        const resultCountEl = document.getElementById('result-count');
        const pickCountInput = document.getElementById('pick-count');
        const newItemInput = document.getElementById('new-item-input');

        renderSettings();
        updatePool(); 

        function handleEnter(e) { if(e.key === 'Enter') addItem(); }

        function addItem() {
            const val = newItemInput.value.trim();
            // Allow same name? Ideally no, to avoid confusion.
            if (val && !itemsData.some(i => i.name === val)) {
                itemsData.push({ name: val, count: 1, distinct: true }); // Default distinct for clarity
                newItemInput.value = '';
                renderSettings();
                updatePool();
            }
        }

        function deleteItem(index) {
            itemsData.splice(index, 1);
            renderSettings();
            updatePool();
        }

        function updateItemCount(index, newCount) {
            let val = parseInt(newCount);
            if(val < 1) val = 1;
            itemsData[index].count = val;
            updatePool();
        }

        function toggleDistinct(index) {
            itemsData[index].distinct = !itemsData[index].distinct;
            updatePool();
        }

        function renderSettings() {
            settingsListEl.innerHTML = '';
            itemsData.forEach((item, idx) => {
                const col = colors[idx % colors.length];
                const li = document.createElement('li');
                li.className = 'settings-item';
                
                li.innerHTML = `
                    <div class="item-header">
                        <span style="display:flex; align-items:center; gap:8px;">
                            <span style="display:inline-block; width:12px; height:12px; border-radius:50%; background:${col};"></span>
                            ${item.name}
                        </span>
                        <button style="color:#e74c3c; background:none; font-size:16px;" onclick="deleteItem(${idx})">×</button>
                    </div>
                    <div class="item-config">
                        <label>個数:</label>
                        <input type="number" class="count-input" value="${item.count}" min="1" onchange="updateItemCount(${idx}, this.value)">
                        
                        <label style="margin-left:10px; display:flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="checkbox" ${item.distinct ? 'checked' : ''} onchange="toggleDistinct(${idx})">
                            区別する
                        </label>
                    </div>
                `;
                settingsListEl.appendChild(li);
            });
        }

        function setMethod(method) {
            currentMethod = method;
            document.querySelectorAll('.method-btn').forEach(b => b.classList.remove('active'));
            if(method === 'permutation') document.getElementById('btn-perm').classList.add('active');
            if(method === 'circular') document.getElementById('btn-circ').classList.add('active');
            if(method === 'combination') document.getElementById('btn-comb').classList.add('active');
            updateCalc();
        }

        function setViewMode(mode) {
            viewMode = mode;
            document.getElementById('btn-view-visual').classList.toggle('active', mode === 'visual');
            document.getElementById('btn-view-tree').classList.toggle('active', mode === 'tree');
            calculateAndRender(); 
        }

        function updateConstraint(checkbox) {
            const item = checkbox.dataset.item;
            const col = parseInt(checkbox.dataset.col);
            if (!matrixConstraints[item]) matrixConstraints[item] = [];
            matrixConstraints[item][col] = checkbox.checked;
            calculateAndRender();
        }

        function updatePool() {
            // Generate pool based on settings
            currentPool = [];
            itemsData.forEach(item => {
                for(let i=1; i<=item.count; i++) {
                    if (item.distinct) {
                        if (item.count === 1) {
                             currentPool.push(item.name);
                        } else {
                             const suffix = (i <= 20) ? String.fromCharCode(0x2460 + i - 1) : `(${i})`;
                             currentPool.push(`${item.name}${suffix}`);
                        }
                    } else {
                        // Indistinct -> just name
                        currentPool.push(item.name);
                    }
                }
            });
            renderMatrix();
            calculateAndRender();
        }

        function updateCalc() {
            renderMatrix();
            calculateAndRender();
        }

        function renderMatrix() {
            const r = parseInt(pickCountInput.value) || 0;
            if (r <= 0) {
                matrixContainer.innerHTML = '数値を正しく入力してください';
                return;
            }
            
            let html = '<table class="matrix-table"><thead><tr><th></th>';
            for (let i = 1; i <= r; i++) html += `<th>${i}</th>`;
            html += '</tr></thead><tbody>';

            currentPool.forEach((item, idx) => {
                html += `<tr><td><strong>${item}</strong></td>`;
                for (let colIdx = 0; colIdx < r; colIdx++) {
                    const isChecked = matrixConstraints[item] && matrixConstraints[item][colIdx] !== undefined 
                                      ? matrixConstraints[item][colIdx] 
                                      : false; 
                    html += `<td><input type="checkbox" class="matrix-checkbox" data-item="${item}" data-col="${colIdx}" ${isChecked ? 'checked' : ''} onchange="updateConstraint(this)"></td>`;
                }
                html += '</tr>';
            });
            html += '</tbody></table>';
            matrixContainer.innerHTML = html;
        }

        function calculateAndRender() {
            const r = parseInt(pickCountInput.value);
            
            if (currentPool.length === 0 || r <= 0) {
                groupsOutput.innerHTML = '';
                resultCountEl.textContent = '0 通り';
                return;
            }

            const poolIndices = currentPool.map((_, i) => i);
            let indexResults = getPermutationsIndices(poolIndices, r);

            const allowedPerCol = [];
            for (let i = 0; i < r; i++) {
                let allowedItems = []; 
                let hasConstraint = false;
                for (let key in matrixConstraints) {
                    if (matrixConstraints[key][i]) {
                        allowedItems.push(key);
                        hasConstraint = true;
                    }
                }
                allowedPerCol.push(hasConstraint ? allowedItems : null);
            }

            let valResults = [];
            indexResults.forEach(indices => {
                const seq = indices.map(idx => currentPool[idx]);
                let valid = true;
                for (let i = 0; i < seq.length; i++) {
                    const allowed = allowedPerCol[i];
                    if (allowed !== null && !allowed.includes(seq[i])) {
                        valid = false;
                        break;
                    }
                }
                if (valid) valResults.push(seq);
            });

            const uniqueSet = new Set();
            let finalResults = [];
            
            valResults.forEach(seq => {
                let keySeq = [...seq];
                if (currentMethod === 'combination') {
                    keySeq.sort();
                } else if (currentMethod === 'circular') {
                    let minStr = keySeq.join('||');
                    let bestRot = [...keySeq];
                    for(let i=1; i<keySeq.length; i++) {
                        const rot = [...keySeq.slice(i), ...keySeq.slice(0, i)];
                        const str = rot.join('||');
                        if (str < minStr) {
                            minStr = str;
                            bestRot = rot;
                        }
                    }
                    keySeq = bestRot;
                }

                const key = keySeq.join('||');
                if (!uniqueSet.has(key)) {
                    uniqueSet.add(key);
                    finalResults.push(keySeq);
                }
            });

            // Standard lexicographical sort (for consistent display within groups)
            finalResults.sort();
            resultCountEl.textContent = `${finalResults.length} 通り`;
            renderGroups(finalResults);
        }

        function getPermutationsIndices(arr, k) {
            if (k === 0) return [[]];
            let res = [];
            for (let i = 0; i < arr.length; i++) {
                const rest = [...arr];
                rest.splice(i, 1);
                const sub = getPermutationsIndices(rest, k - 1);
                sub.forEach(s => res.push([arr[i], ...s]));
            }
            return res;
        }

        // Helper to find original index of item to control sorting order
        function getItemRank(val) {
            // Remove suffix for name matching
            const baseName = val.replace(/[①-⑳\(\)\d]/g, '');
            // Find in itemsData
            let idx = itemsData.findIndex(i => i.name === baseName);
            // If strict match fails, try startsWith (though strict is better for robustness)
            if(idx < 0) idx = itemsData.findIndex(i => val.startsWith(i.name));
            return idx;
        }

        function renderGroups(results) {
            groupsOutput.innerHTML = '';
            if (results.length === 0) return;

            const groups = {};
            results.forEach(seq => {
                const key = seq[0];
                if (!groups[key]) groups[key] = [];
                groups[key].push(seq);
            });

            // SORT MODIFICATION: Use item rank instead of alphabetical
            const sortedKeys = Object.keys(groups).sort((a, b) => {
                const rankA = getItemRank(a);
                const rankB = getItemRank(b);
                // If ranks are equal (shouldn't happen for distinct types) or not found, fallback to string sort
                if (rankA === rankB) return a.localeCompare(b);
                return rankA - rankB;
            });

            sortedKeys.forEach(key => {
                const groupItems = groups[key];
                
                const block = document.createElement('div');
                block.className = 'group-block';
                
                const keyColor = getItemColor(key);
                block.style.borderLeftColor = keyColor;

                const header = document.createElement('div');
                header.className = 'group-header';
                
                let labelText = "";
                if(currentMethod === 'permutation') labelText = `「${key}」から始まる`;
                else if(currentMethod === 'circular') labelText = `「${key}」を固定 (基準)`;
                else labelText = `「${key}」を含む (辞書順)`;

                header.innerHTML = `
                    <span style="display:flex; align-items:center; gap:10px;">
                        <span style="width:14px; height:14px; background:${keyColor}; border-radius:50%; display:inline-block;"></span>
                        ${labelText}
                    </span>
                    <span class="group-count">${groupItems.length} 通り</span>
                `;
                block.appendChild(header);

                const content = document.createElement('div');
                content.className = 'group-content';
                
                if (viewMode === 'visual') {
                    content.classList.add('visual-mode');
                    content.classList.remove('tree-mode');
                    groupItems.forEach(seq => {
                        const viz = document.createElement('div');
                        viz.className = 'viz-card';
                        if (currentMethod === 'permutation') viz.appendChild(renderLinear(seq));
                        else if (currentMethod === 'circular') viz.appendChild(renderCircular(seq));
                        else viz.appendChild(renderGroup(seq));
                        content.appendChild(viz);
                    });
                } else {
                    content.classList.add('tree-mode');
                    content.classList.remove('visual-mode');
                    
                    const remainingSeqs = groupItems.map(s => s.slice(1));
                    const trie = buildTrie(remainingSeqs);
                    // Tree visualization logic...
                    // Since trie keys are sorted alphabetically inside createBranch, 
                    // we might want them to respect rank too? 
                    // But usually branches are OK alphabetical. 
                    // Let's strictly follow "Item Order" for the Root Groups (done above).
                    // For branches, let's also apply rank sort for consistency.
                    
                    const rootBranch = document.createElement('div');
                    rootBranch.className = 'tf-tree'; 
                    const rootText = document.createElement('div');
                    rootText.className = 'tf-nc';
                    rootText.textContent = key;
                    rootBranch.appendChild(rootText);

                    if (Object.keys(trie).length > 0) {
                        const conn = document.createElement('div');
                        conn.className = 'tf-connector';
                        rootBranch.appendChild(conn);
                        const childGroup = document.createElement('div');
                        childGroup.className = 'tf-children';
                        
                        // Apply Rank Sort to children keys too
                        const sortedChildKeys = Object.keys(trie).sort((a,b) => getItemRank(a) - getItemRank(b));
                        
                        sortedChildKeys.forEach(k => {
                            childGroup.appendChild(createBranch(k, trie[k]));
                        });
                        rootBranch.appendChild(childGroup);
                    }
                    content.appendChild(rootBranch);
                }

                block.appendChild(content);
                groupsOutput.appendChild(block);
            });
        }

        // Helper recursive function for tree with Rank Sorting
        function createBranch(label, childrenObj) {
            const branch = document.createElement('div');
            branch.className = 'tf-branch';
            const text = document.createElement('div');
            text.className = 'tf-nc';
            text.textContent = label;
            branch.appendChild(text);

            const childKeys = Object.keys(childrenObj);
            if (childKeys.length > 0) {
                // Apply Rank Sort
                childKeys.sort((a, b) => getItemRank(a) - getItemRank(b));

                const conn = document.createElement('div');
                conn.className = 'tf-connector';
                branch.appendChild(conn);
                const childGroup = document.createElement('div');
                childGroup.className = 'tf-children';
                childKeys.forEach(k => {
                    childGroup.appendChild(createBranch(k, childrenObj[k]));
                });
                branch.appendChild(childGroup);
            }
            return branch;
        }

        function buildTrie(sequences) {
            let root = {};
            sequences.forEach(seq => {
                let current = root;
                seq.forEach(val => {
                    if (!current[val]) current[val] = {};
                    current = current[val];
                });
            });
            return root;
        }

        function getItemColor(val) {
            // Remove suffix for color matching
            const baseName = val.replace(/[①-⑳\(\)\d]/g, '');
            // Find in itemsData
            let idx = itemsData.findIndex(i => i.name === baseName);
            if(idx < 0) idx = itemsData.findIndex(i => val.startsWith(i.name));
            return idx >= 0 ? colors[idx % colors.length] : '#999';
        }

        function createNode(val) {
            const div = document.createElement('div');
            div.className = 'node';
            div.style.backgroundColor = getItemColor(val);
            div.textContent = val;
            return div;
        }
        function renderLinear(seq) {
            const el = document.createElement('div');
            el.className = 'layout-linear';
            seq.forEach((val, i) => {
                el.appendChild(createNode(val));
                if(i < seq.length - 1) {
                    const arrow = document.createElement('span');
                    arrow.className = 'arrow';
                    arrow.innerHTML = '→';
                    el.appendChild(arrow);
                }
            });
            return el;
        }
        function renderCircular(seq) {
            const el = document.createElement('div');
            el.className = 'layout-circular';
            const bg = document.createElement('div');
            bg.className = 'circular-bg';
            el.appendChild(bg);
            const r = 60; const cx = 80, cy = 80;
            const step = (2 * Math.PI) / seq.length;
            seq.forEach((val, i) => {
                const angle = i * step - (Math.PI / 2);
                const x = cx + r * Math.cos(angle);
                const y = cy + r * Math.sin(angle);
                const node = createNode(val);
                node.classList.add('circular-node');
                node.style.left = `${x}px`;
                node.style.top = `${y}px`;
                if (i===0) { node.style.border = "2px solid #333"; node.style.zIndex = 10; }
                el.appendChild(node);
            });
            return el;
        }
        function renderGroup(seq) {
            const el = document.createElement('div');
            el.className = 'layout-group';
            seq.forEach(val => el.appendChild(createNode(val)));
            return el;
        }
    </script>
</body>
</html>
